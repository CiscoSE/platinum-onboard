# Platinum Onboard - Guest Update API

## Description
The Guest Update micro-service is responsible for receiving the Email ID from the broker service, and then interacting with Cisco Identity Services Engine ( ISE ) via its API infrastructure.  The email ID is first checked within ISE to see if it is a current user already in the Database.  If the user is NOT already there, then it adds the user into the the Guest Database with the following defaults:

  **Email Address** = Email ID that is passed via the Broker service.
  **Start and End Date** = This is set for the current day, and is only valid for that particular day.
  **User Name** = This is setup as the email ID as well.  This helps support uniqueness in the environment.
  **Password** = This is the Guest password that will be used for network authentication.  It is autogenerated from a password generating API created within the script.

If the user is already generated, then the API will check to see if the user is active or not.  If active, the script then ends, since there is really nothing for it to do at this end.  If the user is shown as inactive, it means the user was previously created and the account has since expired. In this circumstance, it doesn't have to be recreated by default.  The API will then enable the user for another day and reset its password to a new one for security reasons.

After the ISE portion of the configuration is complete, the Guest Update API talks back to the Broker service by setting the status to completed, as well as sending over the generated password to be inserted into the Broker DB.

## Requirements
The Guest Update API is written in PHP.  The API runs on top of an Apache stack running within Debian Linux.  This PHP interface could be run in any platform running the appropriate version of PHP.  In this topology, we are running the following versions:

Apache 2.4.34
PHP 7.2.9-1

## Apache and PHP Installation
Installing Apache and PHP will vary based on the distribution you are running it one.  In our case, we were running Kali Linux on a Raspberry Pi, so our installation instructions will be based on that.

Once on the CLI of the Kali Linux server, you can perform the following steps to get Apache and PHP up and running:
  1.  First get and install the Apache software
    apt-get install apache2

  2.  Once that is complete, make sure you have a working web server.  You can verify this by browsing to the IP address of the Apache server you just installed ( http://IPADDRESS )

  3.  Once the Apache functionality is verified, you can then move onto PHP.  From the CLI, you can install PHP with the following command ( Note, in our case, it was PHP 7.2 )
      apt-get install php7.2

  4.  You may have some prompts you need to answer yes to, but once that is complete, you just need to restart Apache:
      service apache2 restart

  5.  Now that we have a working Apache and PHP stack, we setup our virtual directory for our PHP script.  In this case, we called it api, but it could be anything you want.  For our distribution, we went into our apache2 configuration directory ( /etc/apache2 ) and added a new conf file in both the conf-available and the conf-enabled.  In our case, we named the api.conf.  In our case, both files were the same, and contained the following:

  <Directory /usr/share/api>
      Options +FollowSymLinks
      AllowOverride None
      <IfVersion >= 2.3>
              Require all granted
      </IfVersion>
      <IfVersion < 2.3>
              Order Allow,Deny
              Allow from all
      </IfVersion>

      AddType application/x-httpd-php .php

      <IfModule mod_php.c>
              php_flag magic_quotes_gpc Off
              php_flag short_open_tag On
              php_flag register_globals Off
              php_flag register_argc_argv On
              php_flag track_vars On
              # this setting is necessary for some locales
              php_value mbstring.func_overload 0
              php_value include_path .
      </IfModule>

      DirectoryIndex index.php
</Directory>

  6.  Once those files are created and saved, we created the api directory under /usr/share, which is what our configuration documents pointed to.  Once that was complete, we restarted Apache2 again:

      service apache2 restart

  7.  We now placed our php file into that directory, and was able to browse it via the URL;

      http://IPADDRESS/api/guest-update.php

### Cisco Identity Services Engine ( ISE )
Cisco Identity Services Engine is used for both the Guest User database as well as the radius server for both the authentication and authorization of the wireless guest users.  In our setup, we are using ISE version 2.4 Patch 5.  The wireless guest users are authenticating against the Guest User Database within ISE.  Once authenticated, they hit our authorization rules.  We have specific authorization rules that are setup per domain.  We match the username that is authenticated to the authorization rules.  Once hit, the rule then sets the appropriate roles by setting the Cisco av-pair radius attribute to the correct role based on that rule:

  cisco-av-pair = role=guest-cisco

Once authenticated and authorized, and user is now on the network with the appropriate security measures in place.

## Optional Components
The following are optional components, but we chose to include to make it a complete solution as would be installed within a customer environment

#### Cisco Umbrella
Used for content filtering based on the Guest's domain.  This would allow for per domain filtering policies.  I.E, cisco.com user would have a different Content filtering policy compared to another vendor.com.  Allows for more a strict security posture.

#### Cisco Umbrella setup
For our Cisco Umbrella setup, we have a policy predefined for each vendor that we would allow within our environment.  These policies are customized per vendor if we so chose.  This allows for maximum flexibility. These policies are assigned by the Cisco Wireless Lan Controller ( WLC ), which we will discuss how next.  Within Umbrella, these policies exist prior to any default catch all's to ensure they are hit based on the appropriate role.

####Cisco Wireless Lan Controller ( WLC )
The WLC was used in our environment as the wireless control system as well as mapping the Guest Users to Umbrella policies.  Some of this functionality is available on the Meraki side as well.

#### Cisco Wireless Lan Controller
In our environment, we used the Cisco WLC as our wireless controller.  Using the Cisco AV-Pair radius attribute, we could tag individual users to a particular role.  In our case, the role was their domain name.  On the WLC, we integrated our WLC to Umbrella using the Network Device API.  We created local policies on the WLC that mapped a role to an Umbrella policy.  This way, if a Cisco.com user came onto the network, it would take the role of Cisco.com automatically based on the role assigned by ISE.  Once the WLC would see that role, it would assign that user on the SSID the particular Umbrella policy that was predefined.

## API Description
All the following URL call can be made in the Guest User Inteface:

```http://{ip address}:{port}/api/check-guest.php&emailid={value}```


#### /api/check-guest.php
**Request Type:** GET

**Parameter**: ```emailid```

**Description:** The emailid is the email address of the guest user in question.  This will get checked against the current ISE Guest User database, and then POST'ed back to the broker service with the updated status and password that was auto generated.
